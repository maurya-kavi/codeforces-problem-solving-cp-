#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp>using namespace std;using namespace __gnu_pbds; // macros#define ll long long#define yes cout << "YES\n"#define no cout << "NO\n"#define f(i, size) for (int i = 0; i < size; i++)// #define ia(a, n) \//     int a[n];     \//     f(i, n) cin >> a[i] #define iv(v, n)     \    vector<ll> v(n); \    f(i, n) cin >> v[i] // #define M (1000000007)#define INF 1000000000000000000LL#define mp make_pair#define mt make_tuple #define nline '\n'#define pb push_back#define pii pair<int, int>#define pll pair<ll, ll>#define vii vector<pair<int, int>> // Sortingbool sorta(const pair<int, int> &a, const pair<int, int> &b) { return (a.second < b.second); }bool sortd(const pair<int, int> &a, const pair<int, int> &b) { return (a.second > b.second); }bool comp1(const pair<int, int> &a, const pair<int, int> &b){    if (a.first == b.first)    {        return a.second < b.second; // ascending order in second element    }    return a.first > b.first; // desc. order in first element} bool comp2(const pair<int, int> &a, const pair<int, int> &b){    if (a.second == b.second)    {        return a.first < b.first; // ascending order in the first element    }    return a.second > b.second; // decending order in the second element} // Bitsstring decToBinary(int n){    string s = "";    int i = 0;    while (n > 0)    {        s = to_string(n % 2) + s;        n = n / 2;        i++;    }    return s;} ll binaryToDecimal(string n){    string num = n;    ll dec_value = 0;    int base = 1;    int len = num.length();    for (int i = len - 1; i >= 0; i--)    {        if (num[i] == '1')            dec_value += base;        base = base * 2;    }    return dec_value;} // Checkbool isPrime(ll n){    if (n <= 1)        return false;    if (n <= 3)        return true;    if (n % 2 == 0 || n % 3 == 0)        return false;    for (int i = 5; i * i <= n; i = i + 6)        if (n % i == 0 || n % (i + 2) == 0)            return false;    return true;} bool isPowerOfTwo(int n){    if (n == 0)        return false;    return (ceil(log2(n)) == floor(log2(n)));} bool isPerfectSquare(ll x){    if (x >= 0)    {        ll sr = sqrt(x);        return (sr * sr == x);    }    return false;} template <typename T>using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; // use:// ordered_set<int> s1;// ordered_set<ll> s2;// ordered_set<pair<int, int>> s3; //Modular arithmetic...................// const int M=1e9+7;const int M = 998244353;long long mod(long long x){    return ((x % M + M) % M);}long long add(long long a, long long b){    return mod(mod(a) + mod(b));}long long mul(long long a, long long b){    return mod(mod(a) * mod(b));} ll modPow(ll a, ll b){    if (b == 0)        return 1LL;    if (b == 1)        return a % M;    ll res = 1;    while (b)    {        if (b % 2 == 1)            res = mul(res, a);        a = mul(a, a);        b = b / 2;    }    return res;} //factorialsconst int N = 2e5 + 2;int fact[N]; void precalc(){    fact[0] = 1;    for (int i = 1; i < N; i++)    {        fact[i] = mul(fact[i - 1], i);    }} ll inv(ll x){    return modPow(x, M - 2);} ll divide(ll a, ll b){    return mul(a, inv(b));} ll nCr(ll n, ll r){    return divide(fact[n], mul(fact[r], fact[n - r]));}//bit manipulation.........................int countSetBits(int n){    return __builtin_popcount(n);} int pow_log2(int x){    return 1 << (31 - __builtin_clz(x));}  void getPrimeFactors(ll n,vector<ll>&factors) {    while (n % 2 == 0) {        factors.push_back(2);        n /= 2;    }    for (int i = 3; i * i <= n; i += 2) {        while (n % i == 0) {            factors.push_back(i);            n /= i;        }    }    if (n > 1) {        factors.push_back(n);    }}//.............................................................................// DSU , path compression and union by sizeconst int N1=1e5+10;int parent[N1];int sz[N1];void make(int v){    parent[v]=v;    sz[v]=1;} int find(int v){    if(v==parent[v]) return v;    return parent[v]=find(parent[v]);  // path compression}  void Union(int a, int b){    a=find(a);    b=find(b);    if(a!=b){        if(sz[a]<sz[b]){            swap(a,b);        }        parent[b]=a;        sz[a]+=sz[b];    }} //MST    // sort(edges.begin(),edges.end());    // for(int i=1; i<=n; i++) make(i);    // ll total_cost=0;    // vector<int>power_stations;    // vector<pair<int,int>>connections;    // for(auto &edge:edges){    //     int wt=edge.first;    //     int u=edge.second.first;    //     int v=edge.second.second;    //     if(find(u)==find(v)) continue; // both are the part of same tree    //     Union(u,v);    //     total_cost+=wt;    //     if(u==0 || v==0) power_stations.pb(max(u,v)); // basically pushing the non zero    //     else connections.pb({u,v});            // }    //   cout<<total_cost<<endl;   void solve(){    ll k,x;    cin>>k>>x;    // vector<ll>v;    ll sum=1;    if(k%2==0){        sum*=k/2;        sum*=(k+1);    }else{        sum*=(k+1)/2;        sum*=k;    }    ll ans=0;    if(sum>=x){         ll l=1, r=k;        while(l<=r){            ll mid=l+(r-l)/2;            ll summ=1;            if(mid%2==0){                summ*=mid/2;                summ*=(mid+1);            }else{                summ*=(mid+1)/2;                summ*=mid;            }            if(summ==x){                ans=mid;                break;            }            else if(summ<x){                if(mid<k) ans=mid+1;                else ans=mid;                l=mid+1;            }else r=mid-1;        }    }    else{        ans=k;        ll remans=0;        ll remx=x-sum;        //k-1 element are left and have to find the noof element will have to take from the left to right elements like k-1,k-2,k-3....,1        ll l=1, r=k-1;        ll kmin1sum=sum-k;        while(l<=r){            ll mid=l+(r-l)/2;            // ll summ=((mid)*(2*(k-1)+(mid-1)*(-1)))/2;            ll rightsumm=1;            if(mid%2==0){                rightsumm*=mid/2;                rightsumm*=(mid+1);            }else{                rightsumm*=(mid+1)/2;                rightsumm*=mid;            }            ll summ=kmin1sum-rightsumm;            if(summ==remx){                remans=(k-1-mid);                break;            }else if(summ<remx){                if((k-1-mid)<(k-1)) remans=(k-1-mid)+1;                else remans=(k-1-mid);                r=mid-1;            }else l=mid+1;         }        ans+=remans;    }    cout<<ans<<nline; } int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);     ll t;    cin >> t;    while (t--) {        solve();    }    return 0;}//.............................................................................