#include <bits/stdc++.h>using namespace std;const int mod=1e9+7;const int inf=1e8;// macros#define ll long long#define yes cout << "YES\n"#define no cout << "NO\n"#define f(i, size) for (int i = 0; i < size; i++)#define ia(a, n) \    int a[n];     \    f(i, n) cin >> a[i] #define iv(v, n)     \    vector<ll> v(n); \    f(i, n) cin >> v[i] // #define M (1000000007)// #define INF 1000000000000000000LL// #define mp make_pair// #define mt make_tuple #define nline '\n'#define pb push_back#define pii pair<int, int>#define pll pair<ll, ll>#define vii vector<pair<int, int>>  // ll n,m;// vector<char>path;// void dfs(vector<vector<char>>&grid, vector<vector<bool>>&visited, int i , int j, int &cntdot, int cnt){//     visited[i][j]=true;//     int dr[]={-1,0,1,0};//     int dc[]={0,1,0,-1};    //     for(int k=0; k<4; k++){//         int nr=dr[k]+i;//         int nc=dc[k]+j;//         if(nr>=0 && nr<n && nc>=0 && nc<m && !visited[nr][nc] && grid[nr][nc]=='.'){//             if(k==0) path.pb('U');//             if(k==1) path.pb('R');//             if(k==2) path.pb('D');//             if(k==3) path.pb('L');//             cnt++;//             dfs(grid, visited, nr, nc, cntdot,cnt);//             //backtrack the path//             path.pop_back();//         }//         if(nr>=0 && nr<n && nc>=0 && nc<m && !visited[nr][nc] && grid[nr][nc]=='B'){//             if(k==0) path.pb('U');//             if(k==1) path.pb('R');//             if(k==2) path.pb('D');//             if(k==3) path.pb('L');//             cntdot=min(cntdot,cnt);//             path.pop_back();//         }//     }// } // int n,m;// void dfs(vector<vector<int>>&roads, vector<bool>&visited, int node){//     visited[node]=true;//     for(auto ngbr:roads[node]){//         if(!visited[ngbr]){//             dfs(roads, visited, ngbr);//         }//     }// }  const ll INF=1e18; int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);      ll n, m;    cin>>n>>m;    vector<vector<pair<ll,ll>>>adj(n);    while(m--){        ll a,b,c;        cin>>a>>b>>c;        a--;        b--;        adj[a].pb({b,c});        adj[b].pb({a,c});    }     priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;    vector<ll>d(n,INF);    vector<ll>p(n,-1);     d[0]=0;    pq.push({0,0}); //0-based node, {dist, node}        while(!pq.empty()){        ll node=pq.top().second;        ll dist=pq.top().first;        pq.pop();                if(d[node]< dist) continue;         for(auto ngbr:adj[node]){            ll to=ngbr.first;            ll len=ngbr.second;            if(d[node] + len < d[to]){                d[to]=d[node]+len;                p[to]=node;                pq.push({d[to],to});            }        }    }     // you can always reach        // for(auto i:d) cout<<i<<" ";    // if(d[n-1]==INF) cout<<-1<<nline;    // else cout<<d[n-1]<<nline;     vector<int>path;    ll node=n-1;    while(node!=-1){        path.pb(node);        node=p[node];    }    if(d[n-1]==INF) {cout<<-1<<nline; return 0;}    reverse(path.begin(), path.end());    for(auto i:path) cout<<i+1<<" ";    cout<<nline;     return 0;}