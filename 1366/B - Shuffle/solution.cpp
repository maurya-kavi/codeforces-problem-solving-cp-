#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp>using namespace std;using namespace __gnu_pbds; // macros#define ll long long#define yes cout << "YES\n"#define no cout << "NO\n"#define f(i, size) for (int i = 0; i < size; i++)// #define ia(a, n) \//     int a[n];     \//     f(i, n) cin >> a[i] #define iv(v, n)     \    vector<ll> v(n); \    f(i, n) cin >> v[i] // #define M (1000000007)#define INF 1000000000000000000LL#define mp make_pair#define mt make_tuple #define nline '\n'#define pb push_back#define pii pair<int, int>#define pll pair<ll, ll>#define vii vector<pair<int, int>> // Sortingbool sorta(const pair<int, int> &a, const pair<int, int> &b) { return (a.second < b.second); }bool sortd(const pair<int, int> &a, const pair<int, int> &b) { return (a.second > b.second); }bool comp1(const pair<int, int> &a, const pair<int, int> &b){    if (a.first == b.first)    {        return a.second < b.second; // ascending order in second element    }    return a.first > b.first; // desc. order in first element} bool comp2(const pair<int, int> &a, const pair<int, int> &b){    if (a.second == b.second)    {        return a.first < b.first; // ascending order in the first element    }    return a.second > b.second; // decending order in the second element} // Bitsstring decToBinary(int n){    string s = "";    int i = 0;    while (n > 0)    {        s = to_string(n % 2) + s;        n = n / 2;        i++;    }    return s;} ll binaryToDecimal(string n){    string num = n;    ll dec_value = 0;    int base = 1;    int len = num.length();    for (int i = len - 1; i >= 0; i--)    {        if (num[i] == '1')            dec_value += base;        base = base * 2;    }    return dec_value;} // Checkbool isPrime(ll n){    if (n <= 1)        return false;    if (n <= 3)        return true;    if (n % 2 == 0 || n % 3 == 0)        return false;    for (int i = 5; i * i <= n; i = i + 6)        if (n % i == 0 || n % (i + 2) == 0)            return false;    return true;} bool isPowerOfTwo(int n){    if (n == 0)        return false;    return (ceil(log2(n)) == floor(log2(n)));} bool isPerfectSquare(ll x){    if (x >= 0)    {        ll sr = sqrt(x);        return (sr * sr == x);    }    return false;} template <typename T>using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; // use:// ordered_set<int> s1;// ordered_set<ll> s2;// ordered_set<pair<int, int>> s3; //Modular arithmetic...................// const int M=1e9+7;const int M = 998244353;long long mod(long long x){    return ((x % M + M) % M);}long long add(long long a, long long b){    return mod(mod(a) + mod(b));}long long mul(long long a, long long b){    return mod(mod(a) * mod(b));} ll modPow(ll a, ll b){    if (b == 0)        return 1LL;    if (b == 1)        return a % M;    ll res = 1;    while (b)    {        if (b % 2 == 1)            res = mul(res, a);        a = mul(a, a);        b = b / 2;    }    return res;} //factorialsconst int N = 2e5 + 2;int fact[N]; void precalc(){    fact[0] = 1;    for (int i = 1; i < N; i++)    {        fact[i] = mul(fact[i - 1], i);    }} ll inv(ll x){    return modPow(x, M - 2);} ll divide(ll a, ll b){    return mul(a, inv(b));} ll nCr(ll n, ll r){    return divide(fact[n], mul(fact[r], fact[n - r]));}//bit manipulation.........................int countSetBits(int n){    return __builtin_popcount(n);} int msb(int x){    return (31 - __builtin_clz(x));}  void getPrimeFactors(ll n,vector<ll>&factors) {    while (n % 2 == 0) {        factors.push_back(2);        n /= 2;    }    for (int i = 3; i * i <= n; i += 2) {        while (n % i == 0) {            factors.push_back(i);            n /= i;        }    }    if (n > 1) {        factors.push_back(n);    }} void getdivisors(ll n, vector<ll>&divisors){    for(ll i=1;i*i<=n;i++){        if(n%i==0){            divisors.push_back(i);            if(n/i!=i){                divisors.push_back(n/i);            }        }    }}//.............................................................................// DSU , path compression and union by sizeconst int N1=1e5+10;int parent[N1];int sz[N1];void make(int v){    parent[v]=v;    sz[v]=1;} int find(int v){    if(v==parent[v]) return v;    return parent[v]=find(parent[v]);  // path compression}  void Union(int a, int b){    a=find(a);    b=find(b);    if(a!=b){        if(sz[a]<sz[b]){            swap(a,b);        }        parent[b]=a;        sz[a]+=sz[b];    }} //MST    // sort(edges.begin(),edges.end());    // for(int i=1; i<=n; i++) make(i);    // ll total_cost=0;    // vector<int>power_stations;    // vector<pair<int,int>>connections;    // for(auto &edge:edges){    //     int wt=edge.first;    //     int u=edge.second.first;    //     int v=edge.second.second;    //     if(find(u)==find(v)) continue; // both are the part of same tree    //     Union(u,v);    //     total_cost+=wt;    //     if(u==0 || v==0) power_stations.pb(max(u,v)); // basically pushing the non zero    //     else connections.pb({u,v});            // }    //   cout<<total_cost<<endl;   void solve() {    ll n,x,m; cin>>n>>x>>m;    ll l=x, r=x;    while(m--){        ll li,ri;        cin>>li>>ri;        // just have to find the maximum window , expand the window if any overlap is there        if((li<l && ri<l) || (li>r && ri>r)){            continue;        }        else{            l=min(li,l);            r=max(ri,r);        }    }    cout<<r-l+1<<endl;}    int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);     ll t;    cin >> t;    while (t--) {        solve();    }    return 0;}//.............................................................................